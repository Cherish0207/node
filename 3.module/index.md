常用的几个模块化规范

- Node 中的模块化规范 commonjs 规范(node 自己实现的),
- es6 Module( Import export),
- umd 统一模块规范,可以兼容 commonjs 和 amd 规范(如果浏览器不支持 commonjs requirejs,直接将变量放到 window 上)
- amd 规范 requirejs cmd 规范
- seajs

- 可以把复杂的代码拆分成小的模块,方便管理代码和维护
- 每个模块之间的内容都是相互独立的,互不影响的(解决变量冲突的问题)单例模式(不能完全解决)使用自执行函数解决

规范的定义--只有这三条:

1. 每个文件都是一个模块
2. 如果你希望模块中的变量被别人使用,可以使用 module.exports 导出这个变量
3. 如果另一个模块想使用这个模块导出的结果需要使用 require 语法来引用（同步）

### 模块的分类

- 核心模块/内置模块: 不是自己写的,也不是安装来的,而是 node 中自己提供的
  `require('fs')`
- 别人写的模块,通过 npm install 安装过来的,就是第三方模块
  `require(commander)`
- 自定义模块: 就是自己写的模块，引用时需要增加路径(相对路径,绝对路径）
  `require('./ promise.js')`

### 核心模块

- fs: filesystems 处理文件
- path: 处理路径
- vm: 写模块化内部需要用到 虚拟机模块、主要功能是为我们提供沙箱环境--很多微前端都提供这样的沙箱环境

#### fs

- 所有的方法基本上都是同步方法、异步方法
  - 同步: 如果刚刚运行程序，希望很快拿到结果，可以去使用同步的, 因为同步方法性能更高一些
  - 异步: 开启一个服务监听客户端访问/ 运行期间

```
因为同步会阻塞，异步是非阻塞的
  如果你开启了服务监听访问，有100个人来访问服务器，
  node是一个单线程的，那它都采用同步的方式去读取文件，那你是不是一个人说我要A文件，那你去读，什么时候读完什么时候把结果返回去，什么时候再处理第二个人的请求，
  所以啊，像我们代码一跑起来之后，一般情况下就需要使用异步了

- 操作文件时尽量使用绝对路径来进行操作，防止指代不明确
  path.resolve() 一定是绝对路径，不能拼接/ 会出错
  path.join() 单纯用来拼接的，不一定是绝对路径，可以拼接/ 会出错 不会吧/解析成跟路径
  path.extneme('a/b/a.min,js') 获取当前路径的扩展名
```

